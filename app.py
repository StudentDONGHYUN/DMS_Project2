# app.py - S-Class DMS System (ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî Î¨∏Ï†ú Ìï¥Í≤∞)

import cv2
import time
import asyncio
from pathlib import Path
from datetime import datetime
import logging
import threading
import queue
import numpy as np

# core Î™®Îìà
from core.definitions import CameraPosition
from core.state_manager import EnhancedStateManager

# integration Î™®Îìà - S-Class ÏãúÏä§ÌÖú
from integration.integrated_system import IntegratedDMSSystem, AnalysisSystemType

# systems Î™®Îìà
from systems.mediapipe_manager import AdvancedMediaPipeManager
from systems.performance import PerformanceOptimizer
from systems.personalization import PersonalizationEngine
from systems.dynamic import DynamicAnalysisEngine
from systems.backup import SensorBackupManager

# io_handler Î™®Îìà
from io_handler.video_input import VideoInputManager, MultiVideoCalibrationManager
from io_handler.ui import SClassAdvancedUIManager

# utils Î™®Îìà - ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞ Ìï®ÏàòÎì§
from utils.drawing import (
    draw_face_landmarks_on_image,
    draw_pose_landmarks_on_image,
    draw_hand_landmarks_on_image,
)
from utils.memory_monitor import MemoryMonitor, log_memory_usage

# ‚úÖ FIXED: OpenCV ÏïàÏ†Ñ Ï≤òÎ¶¨ Ï∂îÍ∞Ä
from utils.opencv_safe import (
    OpenCVSafeHandler,
    safe_create_basic_info_overlay,
    safe_frame_preprocessing_for_mediapipe,
)

logger = logging.getLogger(__name__)

# Ïù¥Ìïò app_backup_20250714_075833.pyÏùò Ï†ÑÏ≤¥ ÏΩîÎìú Î≥µÏõê (DummyAnalysisEngine, IntegratedCallbackAdapter, DMSApp Îì±)


class DummyAnalysisEngine:
    def on_face_result(self, *args, **kwargs):
        pass

    def on_pose_result(self, *args, **kwargs):
        pass

    def on_hand_result(self, *args, **kwargs):
        pass

    def on_object_result(self, *args, **kwargs):
        pass

    frame_buffer = {}


class IntegratedCallbackAdapter:
    """
    ÌÜµÌï© ÏΩúÎ∞± Ïñ¥ÎåëÌÑ∞ - MediaPipe Í≤∞Í≥ºÎ•º IntegratedDMSSystemÏúºÎ°ú Ï†ÑÎã¨ (ÏàòÏ†ïÎêú Î≤ÑÏ†Ñ)
    """

    def __init__(self, integrated_system, result_target=None):
        self.integrated_system = integrated_system
        self.result_target = result_target
        self.result_buffer = {}
        self.processing_lock = asyncio.Lock()
        self.last_processed_timestamp = 0
        self.last_integrated_results = self._get_fallback_results()
        self.RESULT_TIMEOUT = 0.5  # 500ms
        self.MAX_BUFFER_SIZE = 100  # ÏµúÎåÄ Î≤ÑÌçº ÌÅ¨Í∏∞
        self.buffer_cleanup_counter = 0
        logger.info("IntegratedCallbackAdapter (ÏàòÏ†ï) Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

    async def on_face_result(self, result, timestamp=None, *args, **kwargs):
        await self._on_result("face", result, timestamp)

    async def on_pose_result(self, result, timestamp=None, *args, **kwargs):
        await self._on_result("pose", result, timestamp)

    async def on_hand_result(self, result, timestamp=None, *args, **kwargs):
        await self._on_result("hand", result, timestamp)

    async def on_object_result(self, result, timestamp=None, *args, **kwargs):
        await self._on_result("object", result, timestamp)

    async def _on_result(self, result_type, result, timestamp):
        ts = timestamp or int(time.time() * 1000)
        try:
            lock_acquisition_task = asyncio.create_task(self.processing_lock.acquire())
            try:
                await asyncio.wait_for(lock_acquisition_task, timeout=2.0)
                try:
                    if len(self.result_buffer) >= self.MAX_BUFFER_SIZE:
                        await self._emergency_buffer_cleanup()
                    if ts not in self.result_buffer:
                        self.result_buffer[ts] = {"timestamp": time.time()}
                    self.result_buffer[ts][result_type] = result
                    logger.debug(
                        f"Received {result_type} for ts {ts}. Buffer has keys: {list(self.result_buffer[ts].keys())}"
                    )
                    self.buffer_cleanup_counter += 1
                    if self.buffer_cleanup_counter % 10 == 0:
                        await self._prune_buffer()
                    if (
                        "face" in self.result_buffer[ts]
                        and "pose" in self.result_buffer[ts]
                    ):
                        await self._process_results(ts)
                finally:
                    self.processing_lock.release()
            except asyncio.TimeoutError:
                if not lock_acquisition_task.done():
                    lock_acquisition_task.cancel()
                    try:
                        await lock_acquisition_task
                    except asyncio.CancelledError:
                        pass
                raise
        except asyncio.TimeoutError:
            logger.warning(f"Lock ÌöçÎìù ÌÉÄÏûÑÏïÑÏõÉ - {result_type} Í≤∞Í≥º Î¨¥ÏãúÎê® (ts: {ts})")
        except Exception as e:
            logger.error(f"_on_result Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: {e}", exc_info=True)

    async def _process_results(self, timestamp):
        if timestamp <= self.last_processed_timestamp:
            if timestamp in self.result_buffer:
                del self.result_buffer[timestamp]
            return
        results_to_process = self.result_buffer.pop(timestamp, None)
        if not results_to_process:
            return
        logger.info(f"Processing results for timestamp {timestamp}")
        try:
            integrated_results = await self.integrated_system.process_frame(
                results_to_process, timestamp
            )
            self.last_integrated_results = integrated_results
            self.last_processed_timestamp = timestamp
        except Exception as e:
            logger.error(f"ÌÜµÌï© Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {e}", exc_info=True)
            self.last_integrated_results = self._get_fallback_results()
        await self._prune_buffer()

    async def _prune_buffer(self):
        current_time = time.time()
        keys_to_delete = [
            ts
            for ts, data in self.result_buffer.items()
            if current_time - data["timestamp"] > self.RESULT_TIMEOUT
        ]
        for ts in keys_to_delete:
            logger.warning(f"Timeout for timestamp {ts}, removing from buffer.")
            del self.result_buffer[ts]

    async def _emergency_buffer_cleanup(self):
        if len(self.result_buffer) == 0:
            return
        logger.warning(f"Í∏¥Í∏â Î≤ÑÌçº Ï†ïÎ¶¨ Ïã§Ìñâ - ÌòÑÏû¨ ÌÅ¨Í∏∞: {len(self.result_buffer)}")
        sorted_timestamps = sorted(self.result_buffer.keys())
        target_size = max(self.MAX_BUFFER_SIZE // 2, 1)
        current_size = len(self.result_buffer)
        if current_size <= target_size:
            logger.info(
                f"Î≤ÑÌçº ÌÅ¨Í∏∞Í∞Ä Ïù¥ÎØ∏ Î™©Ìëú ÌÅ¨Í∏∞ Ïù¥ÌïòÏûÖÎãàÎã§: {current_size} <= {target_size}"
            )
            return
        items_to_remove = current_size - target_size
        items_to_remove = min(items_to_remove, len(sorted_timestamps))
        removed_count = 0
        for i in range(items_to_remove):
            if i < len(sorted_timestamps):
                ts = sorted_timestamps[i]
                if ts in self.result_buffer:
                    del self.result_buffer[ts]
                    removed_count += 1
        logger.info(
            f"Í∏¥Í∏â Ï†ïÎ¶¨ ÏôÑÎ£å - Ï†úÍ±∞Îêú Ìï≠Î™©: {removed_count}, ÏÉà ÌÅ¨Í∏∞: {len(self.result_buffer)}"
        )

    def get_latest_integrated_results(self):
        return self.last_integrated_results

    def _get_fallback_results(self):
        return {
            "fatigue_risk_score": 0.0,
            "distraction_risk_score": 0.0,
            "confidence_score": 0.0,
            "face_analysis": {},
            "pose_analysis": {},
            "hand_analysis": {},
            "object_analysis": {},
            "fusion_analysis": {},
            "system_health": "unknown",
        }


class DMSApp:
    """
    S-Class DMS Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò - ÌÜµÌï© ÏãúÏä§ÌÖú Ïó∞Îèô ÏàòÏ†ï Î≤ÑÏ†Ñ
    """

    def __init__(
        self,
        input_source=0,
        user_id: str = "default",
        camera_position: CameraPosition = CameraPosition.REARVIEW_MIRROR,
        enable_calibration: bool = True,
        is_same_driver: bool = True,
        system_type: AnalysisSystemType = AnalysisSystemType.STANDARD,
        use_legacy_engine: bool = False,
        sclass_features: dict = None,
        enable_performance_optimization: bool = True,
        edition: str = "RESEARCH",  # üÜï Ï∂îÍ∞ÄÎêú ÌååÎùºÎØ∏ÌÑ∞
    ):
        logger.info("[ÏàòÏ†ï] app_fixed.py: DMSApp.__init__ ÏßÑÏûÖ")
        self.input_source = input_source
        self.user_id = user_id
        self.camera_position = camera_position
        self.enable_calibration = enable_calibration
        self.is_same_driver = is_same_driver
        self.system_type = system_type
        self.use_legacy_engine = use_legacy_engine
        self.sclass_features = sclass_features or {}
        self.edition = edition  # üÜï edition Ï†ÄÏû•
        # üÜï editionÏóê Îî∞Î•∏ Í∏∞Îä• ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî Ï≤òÎ¶¨
        self._configure_edition_features()

        self.running = False
        self.paused = False
        self.current_processed_frame = None
        self.initialization_completed = False
        self.safe_mode = False
        self.error_count = 0
        # GUI/ÏÑ§Ï†ïÏóêÏÑú enable_performance_optimization Í∞íÏùÑ Î∞õÏïÑÏÑú Ï†ÑÎã¨
        self.performance_monitor = PerformanceOptimizer(
            enable_optimization=enable_performance_optimization
        )
        self.personalization_engine = PersonalizationEngine(user_id)
        self.dynamic_analysis = DynamicAnalysisEngine()
        self.backup_manager = SensorBackupManager()
        self.calibration_manager = MultiVideoCalibrationManager(user_id)
        self.memory_monitor = MemoryMonitor(
            warning_threshold_mb=600,
            critical_threshold_mb=1000,
            cleanup_callback=self._perform_memory_cleanup,
        )
        self.ui_manager = SClassAdvancedUIManager()
        if isinstance(input_source, (list, tuple)) and len(input_source) > 1:
            self.calibration_manager.set_driver_continuity(self.is_same_driver)
        logger.info("[ÏàòÏ†ï] S-Class ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

    def _configure_edition_features(self):
        """ÏóêÎîîÏÖòÏóê Îî∞Î•∏ Í∏∞Îä• ÏÑ§Ï†ï"""
        logger.info(f"ÏóêÎîîÏÖò '{self.edition}'Ïóê Îî∞Î•∏ Í∏∞Îä• ÏÑ§Ï†ï Ï§ë...")

        if self.edition == "COMMUNITY":
            # Ïª§ÎÆ§ÎãàÌã∞ ÏóêÎîîÏÖò: Í∏∞Î≥∏ Í∏∞Îä•Îßå
            self.sclass_features.update(
                {
                    "enable_rppg": False,
                    "enable_saccade": False,
                    "enable_spinal_analysis": False,
                    "enable_tremor_fft": False,
                    "enable_bayesian_prediction": False,
                    "enable_emotion_ai": False,
                    "enable_predictive_safety": False,
                    "enable_biometric_fusion": False,
                    "enable_adaptive_thresholds": False,
                }
            )

        elif self.edition == "PRO":
            # ÌîÑÎ°ú ÏóêÎîîÏÖò: S-Class Í≥†Í∏â Í∏∞Îä• Ìè¨Ìï®
            self.sclass_features.update(
                {
                    "enable_rppg": True,
                    "enable_saccade": True,
                    "enable_spinal_analysis": True,
                    "enable_tremor_fft": True,
                    "enable_bayesian_prediction": True,
                    "enable_emotion_ai": False,
                    "enable_predictive_safety": False,
                    "enable_biometric_fusion": False,
                    "enable_adaptive_thresholds": False,
                }
            )

        elif self.edition == "ENTERPRISE":
            # ÏóîÌÑ∞ÌîÑÎùºÏù¥Ï¶à ÏóêÎîîÏÖò: Neural AI Ìè¨Ìï®
            self.sclass_features.update(
                {
                    "enable_rppg": True,
                    "enable_saccade": True,
                    "enable_spinal_analysis": True,
                    "enable_tremor_fft": True,
                    "enable_bayesian_prediction": True,
                    "enable_emotion_ai": True,
                    "enable_predictive_safety": True,
                    "enable_biometric_fusion": True,
                    "enable_adaptive_thresholds": True,
                }
            )

        elif self.edition == "RESEARCH":
            # Ïó∞Íµ¨Ïö© ÏóêÎîîÏÖò: Î™®Îì† Í∏∞Îä• ÌôúÏÑ±Ìôî
            self.sclass_features.update(
                {
                    "enable_rppg": True,
                    "enable_saccade": True,
                    "enable_spinal_analysis": True,
                    "enable_tremor_fft": True,
                    "enable_bayesian_prediction": True,
                    "enable_emotion_ai": True,
                    "enable_predictive_safety": True,
                    "enable_biometric_fusion": True,
                    "enable_adaptive_thresholds": True,
                }
            )

        logger.info(f"ÏóêÎîîÏÖò '{self.edition}' Í∏∞Îä• ÏÑ§Ï†ï ÏôÑÎ£å: {self.sclass_features}")

    async def initialize(self) -> bool:
        logger.info("[ÏàòÏ†ï] S-Class DMS ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏãúÏûë...")
        try:
            self.state_manager = EnhancedStateManager()
            self.video_input_manager = VideoInputManager(self.input_source)
            if not self.video_input_manager.initialize():
                logger.error("ÎπÑÎîîÏò§ ÏûÖÎ†• Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
                return False
            from events.event_bus import initialize_event_system

            try:
                initialize_event_system()  # Í∏∞Ï°¥ ÎèôÍ∏∞ Ìò∏Ï∂ú
                logger.info("‚úÖ Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
            except Exception as e:
                logger.error(f"‚ùå Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
                logger.warning("Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú ÏóÜÏù¥ ÏïàÏ†Ñ Î™®ÎìúÎ°ú Í≥ÑÏÜç ÏßÑÌñâ")
            # 1. ÌÜµÌï© ÏãúÏä§ÌÖú Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
            custom_config = {
                "user_id": self.user_id,
                "camera_position": self.camera_position,
                "enable_calibration": self.enable_calibration,
                "sclass_features": self.sclass_features,
            }
            self.integrated_system = IntegratedDMSSystem(
                system_type=self.system_type,
                custom_config=custom_config,
                use_legacy_engine=self.use_legacy_engine,
            )
            # 2. ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî
            await self.integrated_system.initialize()
            # 3. ÎÇòÎ®∏ÏßÄ Ïª¥Ìè¨ÎÑåÌä∏ Ï¥àÍ∏∞Ìôî
            self.mediapipe_manager = AdvancedMediaPipeManager(DummyAnalysisEngine())
            self.callback_adapter = IntegratedCallbackAdapter(self.integrated_system)
            logger.info("[ÏàòÏ†ï] S-Class DMS ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
            self.initialization_completed = True
            return True
        except Exception as e:
            logger.error(f"S-Class DMS ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}", exc_info=True)
            return False

    def run(self):
        self.running = True
        logger.info("[ÏàòÏ†ï] app.py: run ÏßÑÏûÖ")
        import asyncio

        frame_queue = queue.Queue(maxsize=5)
        stop_event = threading.Event()

        # ‚úÖ FIXED: ÏÜêÏã§Îêú Ï∞∏Ï°∞ Î≥ÄÏàò Ï∂îÍ∞Ä
        self.frame_queue = frame_queue
        self.stop_event = stop_event

        def opencv_display_loop():
            logger.info("[ÏàòÏ†ï] app.py: run - opencv_display_loop ÏßÑÏûÖ")
            last_frame = None
            while not stop_event.is_set():
                try:
                    frame = frame_queue.get(timeout=0.1)
                    if frame is None:
                        break
                    last_frame = frame
                except queue.Empty:
                    pass
                    
                if last_frame is not None:
                    try:
                        # ‚úÖ FIXED: UMat Î≥ÄÌôò Ï†úÍ±∞ - Ïù¥ÎØ∏ numpy arrayÎ°ú Ï≤òÎ¶¨Îê®
                        frame_to_show = last_frame
                        
                        # ÌîÑÎ†àÏûÑ Í≤ÄÏ¶ù
                        if frame_to_show is None:
                            logger.error("frame_to_show is None!")
                            continue
                            
                        if not isinstance(frame_to_show, np.ndarray):
                            logger.error(f"frame_to_show ÌÉÄÏûÖ Ïò§Î•ò: {type(frame_to_show)}")
                            continue
                            
                        if frame_to_show.ndim != 3 or frame_to_show.shape[2] != 3:
                            logger.error(f"frame_to_show shape Ïò§Î•ò: {frame_to_show.shape}")
                            continue
                            
                        # ÏïàÏ†ÑÌïú ÌôîÎ©¥ ÌëúÏãú
                        cv2.imshow("S-Class DMS v18+ - Research Integrated", frame_to_show)
                        
                    except Exception as display_e:
                        logger.error(f"ÌôîÎ©¥ ÌëúÏãú Ïò§Î•ò: {display_e}")
                        # ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ Í≥ÑÏÜç ÏßÑÌñâ
                        
                key = cv2.waitKey(1) & 0xFF
                if key == ord("q"):
                    stop_event.set()
                    break
                elif key == ord("s"):
                    if last_frame is not None:
                        filename = f"screenshot_{int(time.time())}.png"
                        try:
                            cv2.imwrite(filename, last_frame)
                            logger.info(f"Ïä§ÌÅ¨Î¶∞ÏÉ∑ Ï†ÄÏû•: {filename}")
                        except Exception as save_e:
                            logger.error(f"Ïä§ÌÅ¨Î¶∞ÏÉ∑ Ï†ÄÏû• Ïã§Ìå®: {save_e}")
                            
            cv2.destroyAllWindows()

        async def async_frame_producer():
            """
            ‚úÖ FIXED: ÌÜµÌï©Îêú ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ ÌååÏù¥ÌîÑÎùºÏù∏
            """
            logger.info("[ÏàòÏ†ï] ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ ÌîÑÎ°úÎìÄÏÑú ÏãúÏûë")

            # Ï¥àÍ∏∞Ìôî Î∞è Ï§ÄÎπÑ ÎåÄÍ∏∞
            await self.initialize()
            logger.info("[ÏàòÏ†ï] S-Class DMS ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

            # ÏãúÏä§ÌÖú ÏïàÏ†ïÌôîÎ•º ÏúÑÌïú ÏßßÏùÄ ÎåÄÍ∏∞
            await asyncio.sleep(0.1)

            # ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Î£®ÌîÑ Î≥ÄÏàò
            frame_count = 0
            consecutive_errors = 0
            max_consecutive_errors = 5

            # ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î≥ÄÏàò
            from collections import deque

            frame_processing_times = deque(maxlen=100)

            logger.info("ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Î£®ÌîÑ ÏãúÏûë")

            try:
                while not stop_event.is_set():
                    loop_start_time = time.time()

                    try:
                        # === 1. ÌîÑÎ†àÏûÑ ÌöçÎìù (ÎπÑÎèôÍ∏∞Ìôî) ===
                        frame = await self._async_get_frame()
                        if frame is None:
                            await asyncio.sleep(0.01)  # ÏßßÏùÄ ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
                            continue

                        frame_count += 1

                        # === 2. ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ (ÏôÑÏ†Ñ ÎπÑÎèôÍ∏∞) ===
                        annotated_frame = (
                            await self._safe_process_frame_with_error_recovery(
                                frame, frame_count
                            )
                        )

                        # === 3. ÌîÑÎ†àÏûÑ ÌÅêÏóê Ï∂îÍ∞Ä (ÎπÑÎ∏îÎ°úÌÇπ) ===
                        await self._async_enqueue_frame(annotated_frame)

                        # === 4. ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÏµúÏ†ÅÌôî ===
                        frame_time = time.time() - loop_start_time
                        frame_processing_times.append(frame_time)

                        # 30ÌîÑÎ†àÏûÑÎßàÎã§ ÏÑ±Îä• Î°úÍπÖ Î∞è ÏµúÏ†ÅÌôî
                        if frame_count % 30 == 0:
                            await self._async_performance_optimization(
                                frame_processing_times
                            )

                        # Ïó∞ÏÜç Ïò§Î•ò Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
                        consecutive_errors = 0

                        # Ï†ÅÏùëÌòï ÎåÄÍ∏∞ ÏãúÍ∞Ñ (Î™©Ìëú FPS Í∏∞Ï§Ä)
                        target_frame_time = 1.0 / 60.0  # 60 FPS Î™©Ìëú
                        remaining_time = target_frame_time - frame_time
                        if remaining_time > 0:
                            await asyncio.sleep(remaining_time)

                    except (asyncio.CancelledError, KeyboardInterrupt):
                        logger.info("Frame processing loop cancelled.")
                        break
                    except Exception as e:
                        logger.info("ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Î£®ÌîÑ Ï¢ÖÎ£å")
                        break

                logger.info("ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Î£®ÌîÑ Ï¢ÖÎ£å")

                # Ï†ïÎ¶¨ Ïã†Ìò∏ Ï†ÑÏÜ°
                try:
                    frame_queue.put(None, timeout=0.1)
                except queue.Full:
                    pass

            finally:
                # Ï†ïÎ¶¨ ÏûëÏóÖ
                try:
                    if hasattr(self, "mediapipe_manager"):
                        await self.mediapipe_manager.close()
                    if hasattr(self, "integrated_system"):
                        await self.integrated_system.shutdown()
                except Exception as e:
                    logger.warning(f"Ï†ïÎ¶¨ ÏûëÏóÖ Ï§ë Ïò§Î•ò: {e}")

        try:
            # Í∏∞Ï°¥ Ïã§Ìñâ ÏΩîÎìú
            display_thread = threading.Thread(target=opencv_display_loop)
            display_thread.start()
            asyncio.run(async_frame_producer())
            stop_event.set()
            display_thread.join()
        finally:
            # finally Î∏îÎ°ùÏóêÏÑúÎäî Îçî Ïù¥ÏÉÅ asyncio.run()ÏùÑ Ìò∏Ï∂úÌïòÏßÄ ÏïäÏùå
            pass

    def _create_basic_info_overlay(self, frame, frame_count, perf_stats=None):
        """
        ‚úÖ FIXED: ÏïàÏ†ÑÌïú Í∏∞Î≥∏ Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ± (Í∏∞Ï°¥ UMat Ïò§Î•ò Ìï¥Í≤∞)
        """
        try:
            # ÏïàÏ†ÑÌïú Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ± ÏÇ¨Ïö©
            return safe_create_basic_info_overlay(frame, frame_count, perf_stats)
        except (cv2.error, TypeError, ValueError) as e:
            logger.error(f"ÏïàÏ†ÑÌïú Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            # ÏµúÏ¢Ö Ìè¥Î∞±: ÏõêÎ≥∏ ÌîÑÎ†àÏûÑ Î∞òÌôò ÎòêÎäî Ìè¥Î∞± ÌîÑÎ†àÏûÑ ÏÉùÏÑ±
            if frame is not None:
                return frame
            else:
                return OpenCVSafeHandler.create_fallback_frame()

    def _perform_memory_cleanup(self):
        """DMS ÏãúÏä§ÌÖú Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏûëÏóÖ"""
        logger.info("Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ïã§Ìñâ")

        try:
            # 1. Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò Ïã§Ìñâ
            import gc

            before_cleanup = self._get_memory_usage()

            # Î™®Îì† ÏÑ∏ÎåÄÏùò Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò Ïã§Ìñâ
            collected_objects = 0
            for generation in range(3):
                collected = gc.collect(generation)
                collected_objects += collected
                if collected > 0:
                    logger.debug(f"GC ÏÑ∏ÎåÄ {generation}: {collected}Í∞ú Í∞ùÏ≤¥ Ï†ïÎ¶¨")

            logger.info(f"Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò ÏôÑÎ£å: Ï¥ù {collected_objects}Í∞ú Í∞ùÏ≤¥ Ï†ïÎ¶¨")

            # 2. MediaPipe Í¥ÄÎ†® Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
            if hasattr(self, "mediapipe_manager") and self.mediapipe_manager:
                try:
                    # MediaPipe Í≤∞Í≥º Î≤ÑÌçº Ï†ïÎ¶¨
                    if hasattr(self.mediapipe_manager, "clear_result_buffers"):
                        self.mediapipe_manager.clear_result_buffers()
                        logger.debug("MediaPipe Í≤∞Í≥º Î≤ÑÌçº Ï†ïÎ¶¨ ÏôÑÎ£å")

                    # MediaPipe ÎÇ¥Î∂Ä Ï∫êÏãú Ï†ïÎ¶¨
                    if hasattr(self.mediapipe_manager, "cleanup_cache"):
                        self.mediapipe_manager.cleanup_cache()
                        logger.debug("MediaPipe Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å")
                except (AttributeError, TypeError) as e:
                    logger.warning(f"MediaPipe Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

            # 3. ÌÜµÌï© ÏãúÏä§ÌÖú ÏΩúÎ∞± Ïñ¥ÎåëÌÑ∞ Ï†ïÎ¶¨
            if hasattr(self, "callback_adapter") and self.callback_adapter:
                try:
                    # Í≤∞Í≥º Î≤ÑÌçº Ï†ïÎ¶¨
                    if hasattr(self.callback_adapter, "result_buffer"):
                        buffer_size = len(self.callback_adapter.result_buffer)
                        self.callback_adapter.result_buffer.clear()
                        logger.debug(
                            f"ÏΩúÎ∞± Ïñ¥ÎåëÌÑ∞ Î≤ÑÌçº Ï†ïÎ¶¨: {buffer_size}Í∞ú Ìï≠Î™© Ï†úÍ±∞"
                        )

                    # Í∏¥Í∏â Î≤ÑÌçº Ï†ïÎ¶¨ Ïã§Ìñâ
                    if hasattr(self.callback_adapter, "_emergency_buffer_cleanup"):
                        import asyncio

                        if asyncio.iscoroutinefunction(
                            self.callback_adapter._emergency_buffer_cleanup
                        ):
                            # ÎπÑÎèôÍ∏∞ Ìï®ÏàòÏù∏ Í≤ΩÏö∞ ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ïã§Ìñâ
                            loop = None
                            try:
                                loop = asyncio.get_running_loop()
                            except RuntimeError:
                                pass

                            if loop and loop.is_running():
                                # Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù∏ Î£®ÌîÑÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ ÌÉúÏä§ÌÅ¨Î°ú ÏÉùÏÑ±
                                asyncio.create_task(
                                    self.callback_adapter._emergency_buffer_cleanup()
                                )
                            else:
                                # ÏÉà Î£®ÌîÑÏóêÏÑú Ïã§Ìñâ
                                asyncio.run(
                                    self.callback_adapter._emergency_buffer_cleanup()
                                )
                        else:
                            self.callback_adapter._emergency_buffer_cleanup()
                        logger.debug("ÏΩúÎ∞± Ïñ¥ÎåëÌÑ∞ Í∏¥Í∏â Ï†ïÎ¶¨ ÏôÑÎ£å")
                except (AttributeError, TypeError, RuntimeError) as e:
                    logger.warning(f"ÏΩúÎ∞± Ïñ¥ÎåëÌÑ∞ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

            # 4. ÌÜµÌï© ÏãúÏä§ÌÖú Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
            if hasattr(self, "integrated_system") and self.integrated_system:
                try:
                    # Î∂ÑÏÑù ÏóîÏßÑ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
                    if hasattr(self.integrated_system, "analysis_engine"):
                        engine = self.integrated_system.analysis_engine

                        # Í∞Å Î∂ÑÏÑùÍ∏∞Ïùò Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
                        cleanup_methods = [
                            "clear_buffers",
                            "cleanup_memory",
                            "reset_buffers",
                            "clear_cache",
                            "cleanup_resources",
                        ]

                        for method_name in cleanup_methods:
                            if hasattr(engine, method_name):
                                try:
                                    method = getattr(engine, method_name)
                                    method()
                                    logger.debug(f"Î∂ÑÏÑù ÏóîÏßÑ {method_name} ÏôÑÎ£å")
                                except Exception as e:
                                    logger.debug(f"Î∂ÑÏÑù ÏóîÏßÑ {method_name} Ïã§Ìå®: {e}")

                    # ÌÜµÌï© ÏãúÏä§ÌÖú Ï†ÑÏ≤¥ Ï†ïÎ¶¨
                    if hasattr(self.integrated_system, "cleanup_memory"):
                        self.integrated_system.cleanup_memory()
                        logger.debug("ÌÜµÌï© ÏãúÏä§ÌÖú Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏôÑÎ£å")
                except (AttributeError, TypeError) as e:
                    logger.warning(f"ÌÜµÌï© ÏãúÏä§ÌÖú Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

            # 5. ÌîÑÎ†àÏûÑ Î≤ÑÌçº Î∞è ÌÅê Ï†ïÎ¶¨
            try:
                # ÌòÑÏû¨ Ï≤òÎ¶¨Îêú ÌîÑÎ†àÏûÑ Ï†ïÎ¶¨
                if hasattr(self, "current_processed_frame"):
                    self.current_processed_frame = None
                    logger.debug("ÌòÑÏû¨ ÌîÑÎ†àÏûÑ Î≤ÑÌçº Ï†ïÎ¶¨ ÏôÑÎ£å")

                # ÏãúÏä§ÌÖú Íµ¨ÏÑ±ÏöîÏÜåÎì§Ïùò Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
                components = [
                    "performance_monitor",
                    "personalization_engine",
                    "dynamic_analysis",
                    "backup_manager",
                    "calibration_manager",
                ]

                for component_name in components:
                    if hasattr(self, component_name):
                        component = getattr(self, component_name)

                        # Í∞Å Ïª¥Ìè¨ÎÑåÌä∏Ïùò Ï†ïÎ¶¨ Î©îÏÑúÎìú Ìò∏Ï∂ú
                        cleanup_methods = ["cleanup_memory", "clear_cache", "reset"]
                        for method_name in cleanup_methods:
                            if hasattr(component, method_name):
                                try:
                                    method = getattr(component, method_name)
                                    if callable(method):
                                        method()
                                        logger.debug(
                                            f"{component_name}.{method_name} ÏôÑÎ£å"
                                        )
                                except Exception as e:
                                    logger.debug(
                                        f"{component_name}.{method_name} Ïã§Ìå®: {e}"
                                    )
            except (AttributeError, TypeError) as e:
                logger.warning(f"Ïª¥Ìè¨ÎÑåÌä∏ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

            # 6. OpenCV Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
            try:
                import cv2

                # OpenCV ÎÇ¥Î∂Ä Ï∫êÏãú Ï†ïÎ¶¨ (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
                if hasattr(cv2, "setUseOptimized"):
                    cv2.setUseOptimized(True)  # ÏµúÏ†ÅÌôî Ïû¨ÌôúÏÑ±Ìôî
                logger.debug("OpenCV Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏôÑÎ£å")
            except (cv2.error, AttributeError) as e:
                logger.debug(f"OpenCV Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

            # 7. NumPy Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
            try:
                import numpy as np

                # NumPy Î©îÎ™®Î¶¨ ÌíÄ Ï†ïÎ¶¨ (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
                if hasattr(np, "clear_cache"):
                    np.clear_cache()
                    logger.debug("NumPy Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å")
            except AttributeError as e:
                logger.debug(f"NumPy Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {e}")

            # 8. ÏµúÏ¢Ö Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò
            final_collected = gc.collect()
            if final_collected > 0:
                logger.debug(f"ÏµúÏ¢Ö Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò: {final_collected}Í∞ú Í∞ùÏ≤¥ Ï†ïÎ¶¨")

            # 9. Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ ÌôïÏù∏ Î∞è Î°úÍπÖ
            after_cleanup = self._get_memory_usage()
            memory_freed = before_cleanup - after_cleanup

            logger.info(
                f"Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏôÑÎ£å - "
                f"Ï†ïÎ¶¨ Ï†Ñ: {before_cleanup:.1f}MB, "
                f"Ï†ïÎ¶¨ ÌõÑ: {after_cleanup:.1f}MB, "
                f"ÌôïÎ≥¥Îêú Î©îÎ™®Î¶¨: {memory_freed:.1f}MB"
            )

            # 10. Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ìö®Í≥ºÍ∞Ä ÎØ∏ÎØ∏Ìïú Í≤ΩÏö∞ Í≤ΩÍ≥†
            if memory_freed < 10.0:  # 10MB ÎØ∏Îßå
                logger.warning(f"Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ìö®Í≥ºÍ∞Ä Ï†úÌïúÏ†ÅÏûÖÎãàÎã§: {memory_freed:.1f}MB")

                # Ï∂îÍ∞Ä Ï†ïÎ¶¨ ÏûëÏóÖ Ï†úÏïà
                if after_cleanup > 1000:  # 1GB Ïù¥ÏÉÅ ÏÇ¨Ïö© Ï§ë
                    logger.warning(
                        "ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ ÏßÄÏÜç - ÏãúÏä§ÌÖú Ïû¨ÏãúÏûëÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî"
                    )

            return {
                "before_mb": before_cleanup,
                "after_mb": after_cleanup,
                "freed_mb": memory_freed,
                "objects_collected": collected_objects + final_collected,
            }

        except (ImportError, gc.error) as e:
            logger.error(f"Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ï§ë ÏòàÏô∏ Î∞úÏÉù: {e}", exc_info=True)
            return {
                "error": str(e),
                "before_mb": 0,
                "after_mb": 0,
                "freed_mb": 0,
                "objects_collected": 0,
            }

    def _get_memory_usage(self) -> float:
        """ÌòÑÏû¨ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∞òÌôò (MB)"""
        try:
            import psutil

            process = psutil.Process()
            return process.memory_info().rss / 1024 / 1024
        except (ImportError, psutil.Error) as e:
            logger.error(f"Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return 0.0

    # ‚úÖ FIXED: ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨Î•º ÏúÑÌïú Ìó¨Ìçº Ìï®ÏàòÎì§ Ï∂îÍ∞Ä

    async def _async_get_frame(self):
        """
        ‚úÖ ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ ÌöçÎìù
        """
        try:
            # ÎèôÍ∏∞ get_frame()ÏùÑ executorÏóêÏÑú Ïã§ÌñâÌïòÏó¨ ÎπÑÎèôÍ∏∞Ìôî
            loop = asyncio.get_running_loop()
            frame = await loop.run_in_executor(None, self.video_input_manager.get_frame)
            return frame
        except (AttributeError, TypeError) as e:
            logger.debug(f"ÌîÑÎ†àÏûÑ ÌöçÎìù Ïã§Ìå®: {e}")
            return None

    async def _async_enqueue_frame(self, frame):
        """
        ‚úÖ ÎπÑÎèôÍ∏∞ ÌîÑÎ†àÏûÑ ÌÅê Ï∂îÍ∞Ä
        """
        try:
            # ÌÅêÍ∞Ä Í∞ÄÎìù Ï∞¨ Í≤ΩÏö∞ Ïò§ÎûòÎêú ÌîÑÎ†àÏûÑ Ï†úÍ±∞
            if hasattr(self, "frame_queue"):
                try:
                    # ÎπÑÎ∏îÎ°úÌÇπÏúºÎ°ú ÌÅêÏóê Ï∂îÍ∞Ä ÏãúÎèÑ
                    self.frame_queue.put_nowait(frame)
                except queue.Full:
                    # ÌÅêÍ∞Ä Í∞ÄÎìù Ï∞¨ Í≤ΩÏö∞ Í∞ÄÏû• Ïò§ÎûòÎêú ÌîÑÎ†àÏûÑ Ï†úÍ±∞ ÌõÑ Ï∂îÍ∞Ä
                    try:
                        self.frame_queue.get_nowait()  # Ïò§ÎûòÎêú ÌîÑÎ†àÏûÑ Ï†úÍ±∞
                        self.frame_queue.put_nowait(frame)  # ÏÉà ÌîÑÎ†àÏûÑ Ï∂îÍ∞Ä
                    except queue.Empty:
                        # ÌÅêÍ∞Ä ÎπÑÏñ¥ÏûàÎäî Í≤ΩÏö∞ Í∑∏ÎÉ• Ï∂îÍ∞Ä
                        self.frame_queue.put_nowait(frame)
        except (AttributeError, queue.Full) as e:
            logger.warning(f"ÌîÑÎ†àÏûÑ ÌÅê Ï∂îÍ∞Ä Ïã§Ìå®: {e}")

    async def _async_performance_optimization(self, frame_processing_times):
        """
        ‚úÖ ÎπÑÎèôÍ∏∞ ÏÑ±Îä• ÏµúÏ†ÅÌôî
        """
        try:
            # ÌèâÍ∑† ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            import numpy as np

            avg_processing_time = (
                np.mean(frame_processing_times) if frame_processing_times else 0.0
            )
            current_fps = 1.0 / avg_processing_time if avg_processing_time > 0 else 0.0

            # ÏÑ±Îä• ÌÜµÍ≥Ñ Î°úÍπÖ
            logger.info(
                f"ÏÑ±Îä• ÌÜµÍ≥Ñ - FPS: {current_fps:.1f}, ÌèâÍ∑† Ï≤òÎ¶¨ÏãúÍ∞Ñ: {avg_processing_time * 1000:.1f}ms"
            )

            # MediaPipe Î¶¨ÏÜåÏä§ ÎèôÏ†Å Ï°∞Ï†ï
            if hasattr(self, "mediapipe_manager"):
                self.mediapipe_manager.adjust_dynamic_resources()

            # Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ (executorÏóêÏÑú Ïã§Ìñâ)
            loop = asyncio.get_running_loop()
            await loop.run_in_executor(None, self._perform_memory_cleanup)

            # ÏÑ±Îä• Î™®ÎãàÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            if hasattr(self, "performance_monitor") and self.performance_monitor:
                self.performance_monitor.log_performance(
                    avg_processing_time, current_fps
                )

        except (AttributeError, TypeError, ValueError) as e:
            logger.warning(f"ÏÑ±Îä• ÏµúÏ†ÅÌôî Ïã§Ìå®: {e}")

    async def _async_error_recovery(self):
        """
        ‚úÖ ÎπÑÎèôÍ∏∞ Ïò§Î•ò Î≥µÍµ¨
        """
        logger.info("ÏãúÏä§ÌÖú Ïò§Î•ò Î≥µÍµ¨ ÏãúÏûë...")

        try:
            # 1. MediaPipe ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†êÍ≤Ä
            if hasattr(self, "mediapipe_manager"):
                try:
                    health_check = self.mediapipe_manager.get_performance_stats()
                    logger.info(f"MediaPipe ÏÉÅÌÉú: {health_check}")
                except Exception as e:
                    logger.warning(f"MediaPipe ÏÉÅÌÉú Ï†êÍ≤Ä Ïã§Ìå®: {e}")

            # 2. ÌÜµÌï© ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†êÍ≤Ä
            if hasattr(self, "integrated_system"):
                try:
                    # Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú Ïû¨Ï¥àÍ∏∞Ìôî ÏãúÎèÑ
                    from events.event_bus import initialize_event_system

                    initialize_event_system()
                    logger.info("Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú Ïû¨Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
                except Exception as e:
                    logger.warning(f"Ïù¥Î≤§Ìä∏ ÏãúÏä§ÌÖú Ïû¨Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")

            # 3. Î©îÎ™®Î¶¨ Í∞ïÏ†ú Ï†ïÎ¶¨
            loop = asyncio.get_running_loop()
            await loop.run_in_executor(None, self._perform_aggressive_memory_cleanup)

            # 4. Î≥µÍµ¨ ÎåÄÍ∏∞ ÏãúÍ∞Ñ
            await asyncio.sleep(1.0)

            logger.info("ÏãúÏä§ÌÖú Ïò§Î•ò Î≥µÍµ¨ ÏôÑÎ£å")

        except Exception as e:
            logger.error(f"Ïò§Î•ò Î≥µÍµ¨ Ïã§Ìå®: {e}", exc_info=True)

    async def _safe_process_frame_with_error_recovery(self, frame, frame_count):
        """
        ‚úÖ FIXED: Ïò§Î•ò Î≥µÍµ¨ Í∏∞Îä•Ïù¥ ÏûàÎäî ÏïàÏ†ÑÌïú ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ (ÏôÑÏ†Ñ ÏàòÏ†ï)
        """
        try:
            # 1. ÏûÖÎ†• ÌîÑÎ†àÏûÑ Í≤ÄÏ¶ù
            if frame is None:
                logger.warning("None ÌîÑÎ†àÏûÑ ÏûÖÎ†•")
                return OpenCVSafeHandler.create_fallback_frame()

            # 2. MediaPipe Ï†ÑÏ≤òÎ¶¨ (ÏïàÏ†ÑÌïú Ï≤òÎ¶¨)
            try:
                preprocessed_frame = safe_frame_preprocessing_for_mediapipe(frame)
            except Exception as e:
                logger.warning(f"MediaPipe Ï†ÑÏ≤òÎ¶¨ Ïã§Ìå®: {e}")
                preprocessed_frame = frame

            # 3. MediaPipe Í≤∞Í≥º ÌöçÎìù
            try:
                mediapipe_results = await self.mediapipe_manager.process_frame(
                    preprocessed_frame
                )
            except Exception as e:
                logger.warning(f"MediaPipe Ï≤òÎ¶¨ Ïã§Ìå®: {e}")
                # Îπà Í≤∞Í≥ºÎ°ú Í≥ÑÏÜç ÏßÑÌñâ
                mediapipe_results = {
                    'face': None,
                    'pose': None, 
                    'hand': None,
                    'object': None
                }

            # 4. ÌîÑÎ†àÏûÑ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ Ï§ÄÎπÑ (Ïù¥Ï§ë ÌååÏù¥ÌîÑÎùºÏù∏)
            frame_data = {
                "image": preprocessed_frame,  # MediaPipeÏö© numpy Î∞∞Ïó¥
                "frame": preprocessed_frame,  # Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Î≥ÑÏπ≠
                "visualization_frame": None,  # UMatÏùÄ ÌÜµÌï© ÏãúÏä§ÌÖúÏóêÏÑú ÏÉùÏÑ±
                "timestamp": time.time(),
            }

            # MediaPipe Í≤∞Í≥ºÏôÄ ÌîÑÎ†àÏûÑ Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©
            frame_data.update(mediapipe_results)

            # 5. ÌÜµÌï© Î∂ÑÏÑù ÏãúÏä§ÌÖúÏúºÎ°ú Ï≤òÎ¶¨
            try:
                analysis_results = await self.integrated_system.process_and_annotate_frame(
                    frame_data, time.time()
                )
            except Exception as e:
                logger.warning(f"ÌÜµÌï© ÏãúÏä§ÌÖú Ï≤òÎ¶¨ Ïã§Ìå®: {e}")
                # Í∏∞Î≥∏ Í≤∞Í≥º Íµ¨Ï°∞ ÏÉùÏÑ±
                analysis_results = {
                    'fatigue_risk_score': 0.0,
                    'distraction_risk_score': 0.0,
                    'confidence_score': 0.0,
                    'system_health': 'error',
                    'visualization': None
                }

            # 6. ÏãúÍ∞ÅÌôî ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ (ÏïàÏ†ÑÌïú Ï∂îÏ∂ú)
            annotated_frame = None
            
            # ÏãúÍ∞ÅÌôî ÌîÑÎ†àÏûÑÏù¥ Î∂ÑÏÑù Í≤∞Í≥ºÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
            if 'visualization' in analysis_results and analysis_results['visualization'] is not None:
                annotated_frame = analysis_results['visualization']
            else:
                # ÏãúÍ∞ÅÌôî ÌîÑÎ†àÏûÑÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ±
                try:
                    perf_stats = None
                    if hasattr(self, "mediapipe_manager"):
                        perf_stats = self.mediapipe_manager.get_performance_stats()
                    
                    annotated_frame = safe_create_basic_info_overlay(
                        frame, frame_count, perf_stats
                    )
                    
                    # ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌëúÏãú
                    if analysis_results.get('system_health') == 'error':
                        annotated_frame = OpenCVSafeHandler.safe_frame_annotation(
                            annotated_frame,
                            "SYSTEM ERROR - SAFE MODE",
                            position=(10, 120),
                            color=(0, 0, 255),  # Îπ®Í∞ÑÏÉâ
                            font_scale=0.7,
                        )
                        
                except Exception as viz_e:
                    logger.error(f"Í∏∞Î≥∏ Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ± Ïã§Ìå®: {viz_e}")
                    annotated_frame = frame

            # 7. ÌîÑÎ†àÏûÑ ÌÉÄÏûÖ ÏïàÏ†Ñ Ï≤òÎ¶¨ (UMat Ïò§Î•ò Ìï¥Í≤∞)
            if annotated_frame is not None:
                try:
                    # UMatÏùÑ numpy arrayÎ°ú Î≥ÄÌôò (displayÏóê ÏïàÏ†Ñ)
                    if isinstance(annotated_frame, cv2.UMat):
                        # UMat.get()ÏúºÎ°ú numpy array Ï∂îÏ∂ú
                        annotated_frame = annotated_frame.get()
                        
                    # numpy array Í≤ÄÏ¶ù
                    if not isinstance(annotated_frame, np.ndarray):
                        logger.warning(f"ÏòàÏÉÅÏπò Î™ªÌïú ÌîÑÎ†àÏûÑ ÌÉÄÏûÖ: {type(annotated_frame)}")
                        annotated_frame = frame
                        
                    # ÌîÑÎ†àÏûÑ Ï∞®Ïõê Í≤ÄÏ¶ù
                    if annotated_frame.ndim != 3 or annotated_frame.shape[2] != 3:
                        logger.warning(f"ÏûòÎ™ªÎêú ÌîÑÎ†àÏûÑ ÌòïÌÉú: {annotated_frame.shape}")
                        annotated_frame = frame
                        
                except Exception as conv_e:
                    logger.error(f"ÌîÑÎ†àÏûÑ ÌÉÄÏûÖ Î≥ÄÌôò Ïã§Ìå®: {conv_e}")
                    annotated_frame = frame

            return annotated_frame

        except Exception as e:
            logger.error(f"ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Ï§ë ÏπòÎ™ÖÏ†Å Ïò§Î•ò: {e}", exc_info=True)
            
            # ÏµúÏ¢Ö Ìè¥Î∞±: Í∏∞Î≥∏ Ï†ïÎ≥¥ Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ±
            try:
                fallback_frame = safe_create_basic_info_overlay(frame, frame_count, None)
                
                # Ïò§Î•ò ÏÉÅÌÉú ÌëúÏãú
                error_frame = OpenCVSafeHandler.safe_frame_annotation(
                    fallback_frame,
                    f"CRITICAL ERROR: {str(e)[:30]}...",
                    position=(10, 90),
                    color=(0, 0, 255),  # Îπ®Í∞ÑÏÉâ
                    font_scale=0.6,
                )
                
                # UMatÏùÑ numpyÎ°ú Î≥ÄÌôò
                if isinstance(error_frame, cv2.UMat):
                    error_frame = error_frame.get()
                    
                return error_frame
                
            except Exception as final_e:
                logger.error(f"ÏµúÏ¢Ö Ìè¥Î∞±ÎèÑ Ïã§Ìå®: {final_e}")
                # ÏµúÏ¢Ö Ìè¥Î∞±: ÏõêÎ≥∏ ÌîÑÎ†àÏûÑ ÎòêÎäî Í≤ÄÏùÄ ÌôîÎ©¥
                if frame is not None:
                    return frame
                else:
                    return OpenCVSafeHandler.create_fallback_frame()

    def _perform_aggressive_memory_cleanup(self):
        """Í≥µÍ≤©Ï†Å Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ (ÎèôÍ∏∞ Ìï®Ïàò)"""
        try:
            import gc

            # Í∞ÄÎπÑÏßÄ Ïª∂Î†âÏÖò Í∞ïÏ†ú Ïã§Ìñâ
            collected = gc.collect()
            logger.info(f"Í∞ÄÎπÑÏßÄ Ïª∂Î†âÏÖòÏúºÎ°ú {collected}Í∞ú Í∞ùÏ≤¥ Ï†ïÎ¶¨")

            # MediaPipe Í≤∞Í≥º Î≤ÑÌçº Ï†ïÎ¶¨
            if hasattr(self, "callback_adapter") and self.callback_adapter:
                if hasattr(self.callback_adapter, "result_buffer"):
                    self.callback_adapter.result_buffer.clear()
                    logger.info("MediaPipe Í≤∞Í≥º Î≤ÑÌçº Ï†ïÎ¶¨ ÏôÑÎ£å")

            # ÌîÑÎ†àÏûÑ ÌÅê Ï†ïÎ¶¨
            if hasattr(self, "frame_queue"):
                queue_size = self.frame_queue.qsize()
                if queue_size > 0:
                    # ÌÅêÏùò Ï†àÎ∞ò Ï†ïÎ¶¨
                    for _ in range(queue_size // 2):
                        try:
                            self.frame_queue.get_nowait()
                        except queue.Empty:
                            break
                    logger.info(f"ÌîÑÎ†àÏûÑ ÌÅê Ï†ïÎ¶¨: {queue_size // 2}Í∞ú ÌîÑÎ†àÏûÑ Ï†úÍ±∞")

        except (ImportError, gc.error, AttributeError, queue.Empty) as e:
            logger.warning(f"Í≥µÍ≤©Ï†Å Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Ïã§Ìå®: {e}")
